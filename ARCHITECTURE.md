# 3層アーキテクチャ解説

## レイヤーの責務と設計原則

### 1. プレゼンテーション層 (Handler)
- **役割**: HTTP/APIリクエストの受信と処理
- **責務**:
  - リクエストのバリデーション
  - HTTPステータスコードの設定
  - JSONのエンコード/デコード
  - ユースケース層への処理委譲
- **特徴**:
  - プロトコル固有のロジックを含む
  - ビジネスロジックを持たない
  - クライアントとのインターフェース

### 2. ビジネスロジック層 (UseCase)
- **役割**: アプリケーションのコアロジックの実装
- **責務**:
  - ビジネスルールの適用
  - データの変換と加工
  - リポジトリとの連携
  - トランザクション管理
- **特徴**:
  - ドメインロジックの中心
  - インターフェースを介した疎結合
  - 再利用可能なビジネスロジック

### 3. データアクセス層 (Repository)
- **役割**: データベースとの直接的な対話
- **責務**:
  - データの永続化
  - データベースクエリの実行
  - ORMを使用したデータ操作
  - データベース固有のエラーハンドリング
- **特徴**:
  - データベース抽象化
  - データ永続化の詳細を隠蔽
  - データアクセスの一元管理

### 4. ドメインモデル層 (Model)
- **役割**: データ構造とビジネスルールの定義
- **責務**:
  - エンティティの定義
  - データバリデーション
  - ドメイン固有の振る舞い
- **特徴**:
  - 純粋なデータ構造
  - ビジネスルールのカプセル化
  - 他レイヤーから独立

## アーキテクチャの利点
- **関心の分離**: 各レイヤーが明確な責務を持つ
- **保守性の向上**: 変更の影響範囲を最小限に抑える
- **テスト容易性**: 各レイヤーを独立してテスト可能
- **拡張性**: 新機能の追加や変更が容易

## レイヤー間の通信
- 依存の方向: プレゼンテーション → ユースケース → リポジトリ
- インターフェースを使用した疎結合
- 各レイヤーは下位レイヤーのインターフェースに依存

## コード例
```go
// プレゼンテーション層 (Handler)
func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    // リクエストの処理、ユースケース層への委譲
}

// ビジネスロジック層 (UseCase)
func (u *UserUseCase) CreateUser(user *model.User) error {
    // ビジネスルールの適用、リポジトリとの連携
}

// データアクセス層 (Repository)
func (r *UserRepository) Create(user *model.User) error {
    // データベースへの永続化
}
```

## 注意点
- 過度な抽象化を避ける
- レイヤー間の依存関係に注意
- パフォーマンスとのバランスを考慮
